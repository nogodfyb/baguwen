# 典型回答

本地消息表其实也是借助消息来实现分布式事务的。

这个方案的**主要思想是将分布式事务拆分为本地事务和消息事务两个部分**，本地事务在本地数据库中进行提交或回滚，而消息事务则将消息写入消息中间件中，以实现消息的可靠投递和顺序性。

一般来说的做法是，在发送消息之前，先创建一条本地消息，并且保证写本地业务数据的操作，和，写本地消息记录的操作在同一个事务中。这样就能确保只要业务操作成功，本地消息一定可以写成功。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1679213543727-21ced2f1-d04e-4c36-a0f1-fd0b2912e998.png#averageHue=%23fefaf1&clientId=u5fae3e4d-7a9b-4&from=paste&height=779&id=u06978182&originHeight=779&originWidth=2330&originalType=binary&ratio=1&rotation=0&showTitle=false&size=178025&status=done&style=none&taskId=u684f86a8-7c23-4f7a-80b4-213c0c8e882&title=&width=2330)

然后再基于本地消息，调用MQ发送远程消息。

消息发出去之后，等待消费者消费，在消费者端，接收到消息之后，做业务处理，处理成功后再修改本地消息表的状态。

这个过程中，可能有几个步骤都可能发生失败，那么如果失败了怎么办呢？

1、2如果失败，因为在同一个事务中，所以事务会回滚，3及以后的步骤都不会执行。数据是一致的。

3如果失败，那么就需要有一个定时任务，不断的扫描本地消息数据，对于未成功的消息进行重新投递。

4、5如果失败，则依靠消息的重投机制，不断地重试。

6、7如果失败，那么就相当于两个分布式系统中的业务数据已经一致了，但是本地消息表的状态还是错的。这种情况也可以借助定时任务继续重投消息，让下游幂等消费再重新更改消息状态，或者本系统也可以通过定时任务去查询下游系统的状态，如果已经成功了，则直接推进消息状态即可。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1679214074334-3c57700a-30a7-44b2-b1cd-239dc1509da2.png#averageHue=%23fef9f2&clientId=u5fae3e4d-7a9b-4&from=paste&height=1000&id=u932266a8&originHeight=1000&originWidth=2275&originalType=binary&ratio=1&rotation=0&showTitle=false&size=271795&status=done&style=none&taskId=u41e6540c-4386-4cdb-93ad-36a09c4c160&title=&width=2275)

# 扩展知识

## 优缺点

优点：

1. 可靠性高：基于本地消息表实现分布式事务，可以将本地消息的持久化和本地业务逻辑操作，放到一个事务中执行进行原子性的提交，从而保证了消息的可靠性。
2. 可扩展性好：基于本地消息表实现分布式事务，可以将消息的发送和本地事务的执行分开处理，从而提高了系统的可扩展性。
3. 适用范围广：基于本地消息表实现分布式事务，可以适用于多种不同的业务场景，可以满足不同业务场景下的需求。

缺点：

1. 实现复杂度高：基于本地消息表实现分布式事务，需要设计复杂的事务协议和消息发送机制，并且需要进行相应的异常处理和补偿操作，因此实现复杂度较高。
2. 系统性能受限：基于本地消息表实现分布式事务，需要将消息写入本地消息表，并且需要定时扫描本地消息表进行消息发送，因此对系统性能有一定影响。
3. 会带来消息堆积扫表慢、集中式扫表会影响正常业务、定时扫表存在延迟问题等问题。在下文中介绍：

[✅本地消息表实现的分布式的缺点有什么？](https://www.yuque.com/hollis666/fo22bm/gamq6s7qf25cn332?view=doc_embed)

## 代码实践

[✅基于本地消息表实现分布式事务保证最终一致性](https://www.yuque.com/hollis666/fo22bm/hi956hl64rr7cwx1?view=doc_embed)
