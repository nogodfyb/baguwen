# 项目中缓存是如何使用的

## 为什么要用缓存

### 高性能

对于复杂操作耗时查出来的结果，确定后面不怎么变化，但是有很多读请求，直接将查询出来的结果放入缓存，后面直接读缓存就好。

### 高并发

mysql单机2000qps容易报警。

缓存支持几万到几十万qps不是问题，内存天然支持高并发。

## 用了缓存之后有什么不良后果

1. 缓存与数据库双写不一致
2. 缓存雪崩，缓存穿透，缓存击穿
3. 缓存并发竞争

# Redis 和 Memcached 有什么区别

## redis和memcached区别

### redis支持复杂的数据结构

### redis原生支持集群模式

### 性能对比

由于redis使用单核，memcached使用多核。存储100k以上的数据，memcached性能要高于redis。

## redis线程模型

单线程的文件事件处理器，结构如下

1. 多个socket
2. IO多路复用程序
3. 文件事件分派器
4. 事件处理器(连接应答处理器，命令请求处理器，命令回复处理器)

## 单线程效率高

1. 纯内存操作
2. 核心是基于非阻塞的IO多路复用机制
3. C语言实现

## redis6.0开始引入多线程

redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。

# Redis有哪些数据类型以及适用场景

## Strings

最简单的key-value

![](https://raw.githubusercontent.com/nogodfyb/baguwen/master/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E5%AE%8C%E5%85%A8%E6%89%AB%E7%9B%B2/img/1.png)



适合做简单的KV缓存。

## Hashes

类似于map

![](https://raw.githubusercontent.com/nogodfyb/baguwen/master/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E5%AE%8C%E5%85%A8%E6%89%AB%E7%9B%B2/img/2.png)

适合存储一个没有嵌套其他对象的对象。

## Lists

有序列表。

![](https://raw.githubusercontent.com/nogodfyb/baguwen/master/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E5%AE%8C%E5%85%A8%E6%89%AB%E7%9B%B2/img/3.png)

适用场景：存储粉丝列表，文章的评论列表等。高性能分页可以做微博那种不断下拉功能。

## Sets

无序集合，自动去重。

![](https://raw.githubusercontent.com/nogodfyb/baguwen/master/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E5%AE%8C%E5%85%A8%E6%89%AB%E7%9B%B2/img/4.png)

应用场景：交集，并集，差集。例如，粉丝列表查看共同好友。

## Sorted Sets

 可以去重，可以排序的集合。

![](https://raw.githubusercontent.com/nogodfyb/baguwen/master/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E5%AE%8C%E5%85%A8%E6%89%AB%E7%9B%B2/img/5.png)

# Redis的过期策略都有哪些

## 过期策略

### 定期删除

默认每隔100ms**随机抽取一些**设置过期时间的key，检查其是否过期，如果过期就删除。

### 惰性删除

获取Key的时候，如果此时key已经过期，就删除，不会返回任何东西。

## 内存淘汰机制

redis的key太多了，内存不够用，就要走内存淘汰机制。以下是比较常用的几个机制。

**allkeys-lru**：当内存不足以容纳新写入数据时，在**键空间**中，移除最近最少使用的 key（这个是**最常用**的）

**volatile-random:** 当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，**随机移除**某个 key。

**volatile-ttl:** 当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，有**更早过期时间**的 key 优先移除。

# 如何保证Redis高并发高可用

高并发=>主从架构

高可用=>基于哨兵实现

# Redis主从架构是怎样的

Redis replication=>主从架构=>读写分离=>水平扩容支撑读高并发

## replication核心机制

1. 异步方式复制数据到slave节点
2. 一个master node可以配置多个slave node
3. slave node可以连接 其他 slave node
4. slave node做复制的时候，不会阻塞master node的正常工作
5. slave node做复制也不会阻塞自己的查询工作，但是复制完成删除旧的数据集然后加载新数据集，这个时候会暂停对外服务
6. slave node主要用来进行横向扩容，做读写分离，扩容的slave可以提高读的吞吐量

采用主从架构建议必须开启master node的持久化。

## 主从复制核心原理

**slave node初次连接到master node=>full resynchronization全量复制**

master启动一个后台线程=>生成RDB快照文件||并将从client新收到的所有写命令缓存在内存中=>RDB文件发送给SLAVE=>SLAVE先写入本地磁盘=>
本地磁盘加载到内存中=>master将内存中缓存的写命令发送到slave,slave同步这些数据=>slave节点和master有网络故障=>重连仅复制缺失部分的数据

### 主从复制断点续传

从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。

### 无磁盘化复制

master在内存中直接创建RDB，然后发送给slave，不会在自己本地落地磁盘了。配置文件开启

```bash
repl-diskless-sync yes

# 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来
repl-diskless-sync-delay 5
```

### 过期key处理

master过期或者淘汰一个key，模拟一条del命令发送给slave。

## 复制的完整流程

# Redis的持久化有哪几种方式

# Redis如何基于哨兵集群实现高可用

# Redis集群模式的工作原理

# Redis的雪崩，穿透和击穿 如何应对

# 如何保证缓存与数据库双写一致性

# 如何解决Redis的并发竞争问题

# 生产环境中的Redis是怎么部署的