# 项目中缓存是如何使用的

## 为什么要用缓存

### 高性能

对于复杂操作耗时查出来的结果，确定后面不怎么变化，但是有很多读请求，直接将查询出来的结果放入缓存，后面直接读缓存就好。

### 高并发

mysql单机2000qps容易报警。

缓存支持几万到几十万qps不是问题，内存天然支持高并发。

## 用了缓存之后有什么不良后果

1. 缓存与数据库双写不一致
2. 缓存雪崩，缓存穿透，缓存击穿
3. 缓存并发竞争

# Redis 和 Memcached 有什么区别

## redis和memcached区别

### redis支持复杂的数据结构

### redis原生支持集群模式

### 性能对比

由于redis使用单核，memcached使用多核。存储100k以上的数据，memcached性能要高于redis。

## redis线程模型

单线程的文件事件处理器，结构如下

1. 多个socket
2. IO多路复用程序
3. 文件事件分派器
4. 事件处理器(连接应答处理器，命令请求处理器，命令回复处理器)

## 单线程效率高

1. 纯内存操作
2. 核心是基于非阻塞的IO多路复用机制
3. C语言实现

## redis6.0开始引入多线程

redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。

# Redis有哪些数据类型以及适用场景

## Strings

最简单的key-value

![](https://raw.githubusercontent.com/nogodfyb/baguwen/master/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E5%AE%8C%E5%85%A8%E6%89%AB%E7%9B%B2/img/1.png)



适合做简单的KV缓存。

## Hashes

类似于map

![](https://raw.githubusercontent.com/nogodfyb/baguwen/master/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E5%AE%8C%E5%85%A8%E6%89%AB%E7%9B%B2/img/2.png)

适合存储一个没有嵌套其他对象的对象。

## Lists

有序列表。

![](https://raw.githubusercontent.com/nogodfyb/baguwen/master/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E5%AE%8C%E5%85%A8%E6%89%AB%E7%9B%B2/img/3.png)

适用场景：存储粉丝列表，文章的评论列表等。高性能分页可以做微博那种不断下拉功能。

## Sets

无序集合，自动去重。

![](https://raw.githubusercontent.com/nogodfyb/baguwen/master/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E5%AE%8C%E5%85%A8%E6%89%AB%E7%9B%B2/img/4.png)

应用场景：交集，并集，差集。例如，粉丝列表查看共同好友。

## Sorted Sets

 可以去重，可以排序的集合。

![](https://raw.githubusercontent.com/nogodfyb/baguwen/master/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E5%AE%8C%E5%85%A8%E6%89%AB%E7%9B%B2/img/5.png)

# Redis的过期策略都有哪些

## 过期策略

### 定期删除

默认每隔100ms**随机抽取一些**设置过期时间的key，检查其是否过期，如果过期就删除。

### 惰性删除

获取Key的时候，如果此时key已经过期，就删除，不会返回任何东西。

## 内存淘汰机制

redis的key太多了，内存不够用，就要走内存淘汰机制。以下是比较常用的几个机制。

**allkeys-lru**：当内存不足以容纳新写入数据时，在**键空间**中，移除最近最少使用的 key（这个是**最常用**的）

**volatile-lru**：仅在设置了过期时间的键中选择最久未使用的键进行淘汰。

**volatile-random:** 当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，**随机移除**某个 key。

**volatile-ttl:** 当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，有**更早过期时间**的 key 优先移除。

# 如何保证Redis高并发高可用

高并发=>主从架构

高可用=>基于哨兵实现

# Redis主从架构是怎样的

Redis replication=>主从架构=>读写分离=>水平扩容支撑读高并发

## replication核心机制

1. 异步方式复制数据到slave节点
2. 一个master node可以配置多个slave node
3. slave node可以连接 其他 slave node
4. slave node做复制的时候，不会阻塞master node的正常工作
5. slave node做复制也不会阻塞自己的查询工作，但是复制完成删除旧的数据集然后加载新数据集，这个时候会暂停对外服务
6. slave node主要用来进行横向扩容，做读写分离，扩容的slave可以提高读的吞吐量

采用主从架构建议必须开启master node的持久化。

## 主从复制核心原理

**slave node初次连接到master node=>full resynchronization全量复制**

master启动一个后台线程=>生成RDB快照文件||并将从client新收到的所有写命令缓存在内存中=>RDB文件发送给SLAVE=>SLAVE先写入本地磁盘=>
本地磁盘加载到内存中=>master将内存中缓存的写命令发送到slave,slave同步这些数据=>slave节点和master有网络故障=>重连仅复制缺失部分的数据

### 主从复制断点续传

从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。

### 无磁盘化复制

master在内存中直接创建RDB，然后发送给slave，不会在自己本地落地磁盘了。配置文件开启

```bash
repl-diskless-sync yes

# 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来
repl-diskless-sync-delay 5
```

### 过期key处理

master过期或者淘汰一个key，模拟一条del命令发送给slave。

## 复制的完整流程

1. slave启动，在本地保存master node的 host 和 ip
2. slave内部有定时任务，每秒check是否有master连接，如果有就建立socket网络连接
3. 如果master配置了requirepass，那么slave node会发送masterauth口令过去验证
4. master启动全量复制，将自己所有的数据都发送给slave，实现数据的同步
5. 每次master接收到新的数据，都异步发送给slave node

### 全量复制

1. master执行bgsave，在本地生成一份rdb快照文件
2. master node将rdb快照文件发送给slave node
3. master生成rdb时，会将所有新的写命令缓存在内存中，在slave保存了rdb之后，再将新的写命令复制给slave node
4. 复制期间，内存缓冲区持续消耗超过64MB，一次性超过256MB，那么停止复制，复制失败
5. slave node接收到rdb之后，清空自己的旧数据，然后重新加载rdb到自己的内存中
6. 如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF

### 增量复制

1. 全量复制过程中，master 和 slave网络连接断掉，重连会触发增量复制
2. master直接从自己的backlog中获取部分丢失的数据，发送给slave node
3. master就是根据slave发送的psync中的offset来从backlog中获取数据的

### heartbeat

主从节点互相发送心跳信息。

master每10秒发送一次心跳信息，slave每隔1秒发送一次。

### 异步复制

master每次接收到写命令之后，先在内部写入数据，然后异步发送给slave。

# Redis的持久化有哪几种方式

## Redis持久化的两种方式

### RDB

对redis中的数据执行周期性的持久化

### AOF

对每条写入命令作为日志，以append-only的模式写入一个日志文件中，redis重启时，可以通过回放AOF日志的写入命令来重新构建数据集。

## RDB优缺点

**优点**

1. RDB会生成多个数据文件，每个数据文件代表某一个时刻，非常适合做冷备份
2. redis对外提供的读写服务不会受到影响
3. 恢复数据的速度更快

**缺点**

1. redis故障尽可能少丢失数据不如AOF
2. 生成rdb文件如果特别大，可能会导致服务暂停数毫秒至数秒

## AOF优缺点

**优点**

1. 每隔一秒，后台线程执行一次fsync操作，最多丢失一秒钟数据
2. 日志文件以append-only模式写入，没有磁盘寻址开销，写入性能高
3. 日志文件过大的时候，出现后台重写操作，也不会影响客户端的读写
4. 可读性较强，适合做灾难性的误删除的紧急恢复

**缺点**

1. 对于同一份数据，AOF日志文件通常比RDB数据快照文件更大，恢复速度更慢
2. 支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置每秒fsync一次日志文件
3. 相比rdb数据恢复容易有bug

## RDB和AOF到底该如何选择

建议同时开启两种方式：

用AOF来保证数据不丢失，作为数据恢复的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，使用RDB来进行快速的数据恢复。

# Redis如何基于哨兵集群实现高可用

## 哨兵的介绍

sentinel，哨兵是Redis集群架构中非常重要的一个组件

- 集群监控：负责监控Redis master 和 slave 进程是否正常工作
- 消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员
- 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上
- 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址

哨兵用于实现redis集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作

- 故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题
- 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的

## 哨兵的核心知识

- 哨兵至少需要 3 个实例，来保证自己的健壮性
- 哨兵 + Redis 主从的部署架构，是**不保证数据零丢失**的，只能保证 Redis 集群的高可用性

哨兵集群必须部署 2 个以上节点

```
       +----+
       | M1 |
       | S1 |
       +----+
          |
+----+    |    +----+
| R2 |----+----| R3 |
| S2 |         | S3 |
+----+         +----+
```

配置 `quorum=2` ，如果 M1 所在机器宕机了，那么三个哨兵还剩下 2 个，S2 和 S3 可以一致认为 master 宕机了，然后选举出一个来执行故障转移，同时 3 个哨兵的 majority 是 2，所以还剩下的 2 个哨兵运行着，就可以允许执行故障转移。

## Redis哨兵主备切换的数据丢失问题

### 导致数据丢失的两种情况

#### 异步复制导致的数据丢失

因为 master->slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。

#### 脑裂导致的数据丢失

master所在机器突然脱离了正常的网络(实际正常运行)=>哨兵选举其它slave切换为master=>脑裂

client向旧的master写数据=>旧的恢复网络后会成为集群中的slave=>清空数据=>向master复制数据=>丢失数据

### 数据丢失问题的解决方案

```bash
min-slaves-to-write 1
min-slaves-max-lag 10
```

以上配置保证集群环境至少有一个slave，数据复制和同步的延迟不能超过10秒，否则，master就不会接受任何请求了。

**减少异步复制数据的丢失**

min-slaves-max-lag这个配置一旦 slave 复制数据和 ack 延时太长，拒绝客户端的写请求

**减少脑裂的数据丢失**



## sdown-和-odown-转换机制

- sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机
- odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机

## 哨兵集群的自动发现机制

哨兵互相之间的发现，是通过 Redis 的 `pub/sub` 系统实现的

## slave-配置的自动纠正

哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。

## slave->master 选举算法

考虑因素

- 跟 master 断开连接的时长
- slave 优先级
- 复制 offset
- run id

## quorum 和 majority

每次一个哨兵要做主备切换，首先需要 quorum 数量的哨兵认为 odown，然后选举出一个哨兵来做切换，这个哨兵还需要得到 majority 哨兵的授权，才能正式执行切换。

如果 quorum < majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换。

但是如果 quorum >= majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换。

## configuration epoch

哨兵会对一套 Redis master+slaves 进行监控，有相应的监控的配置。

## configuration 传播

哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后同步给其他的哨兵，就是通过之前说的 `pub/sub` 消息机制。

# Redis集群模式的工作原理

## Redis cluster

- 自动将数据进行分片，每个 master 上放一部分数据
- 提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的

在 Redis cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。

16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议， `gossip` 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。

## 节点间的内部通信机制

### 基本通信原理

集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。

**集中式**是将集群元数据（节点信息、故障等等）集中存储在某个节点上。

**集中式**的**好处**在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；**不好**在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。

Redis 维护集群元数据采用另一个方式， `gossip` 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。

- 10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 `ping` 消息，同时其它几个节点接收到 `ping` 之后返回 `pong` 。
- 交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。

### gossip 协议

gossip 协议包含多种消息，包含 `ping` , `pong` , `meet` , `fail` 等等。

- meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。

```bash
Redis-trib.rb add-nodeCopy to clipboardErrorCopied
```

其实内部就是发送了一个 gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群。

- ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。
- pong：返回 ping 和 meet，包含自己的状态和其它信息，也用于信息广播和更新。
- fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机啦。

### ping 消息深入

每次 ping，会带上自己节点的信息，还有就是带上 1/10 其它节点的信息，发送出去，进行交换。至少包含 `3` 个其它节点的信息，最多包含 `总节点数减 2` 个其它节点的信息。

## 分布式寻址算法

- hash 算法（大量缓存重建）
- 一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）
- Redis cluster 的 hash slot 算法

### hash 算法

来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致**大部分的请求过来，全部无法拿到有效的缓存**，导致大量的流量涌入数据库。

### 一致性 hash 算法

### Redis cluster 的 hash slot 算法

任何一台master机器宕机，另外两个master节点，不影响的。因为 key 找的是 hash slot，不是机器。

## Redis cluster 的高可用与主备切换原理

Redis cluster 的高可用的原理，几乎跟哨兵是类似的。

### 判断节点宕机

### 从节点过滤

### 从节点选举

### 与哨兵比较

整个流程跟哨兵相比，非常类似，所以说，Redis cluster 功能强大，直接集成了 replication 和 sentinel 的功能。

# Redis的雪崩，穿透和击穿 如何应对

## 缓存雪崩

当**大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机**时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是**缓存雪崩**的问题

### 大量数据同时过期

- 均匀设置过期时间
- 互斥锁
- 双 key 策略
- 后台更新缓存

*1. 均匀设置过期时间*

如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，**给这些数据的过期时间加上一个随机数**，这样就保证数据不会在同一时间过期。

*2. 互斥锁*

当业务线程在处理用户请求时，**如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存**（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。

实现互斥锁的时候，最好设置**超时时间**，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。

*3. 后台更新缓存*

业务线程不再负责更新缓存，缓存也不设置有效期，而是**让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新**。

事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为**当系统内存紧张的时候，有些缓存数据会被“淘汰”**，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。

### Redis故障宕机

- 服务熔断或请求限流机制；
- 构建 Redis 缓存高可靠集群；

*1. 服务熔断或请求限流机制*

因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动**服务熔断**机制，**暂停业务应用对缓存服务的访问，直接返回错误**，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。

服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作

为了减少对业务的影响，我们可以启用**请求限流**机制，**只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务**，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。

*2. 构建 Redis 缓存高可靠集群*

服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过**主从节点的方式构建 Redis 缓存高可靠集群**。

如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。

## 缓存穿透

当用户访问的数据，**既不在缓存中，也不在数据库中**，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是**缓存穿透**的问题。

### 发生原因

- 业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；
- 黑客恶意攻击，故意大量访问某些读取不存在数据的业务；

### 解决方案

- 第一种方案，非法请求的限制；
- 第二种方案，缓存空值或者默认值；
- 第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；

第一种方案，非法请求的限制

当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。

第二种方案，缓存空值或者默认值

当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。

*第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。*

我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。

即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。

## 缓存击穿

如果缓存中的**某个热点数据过期**了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是**缓存击穿**的问题。

可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。

应对缓存击穿可以采取前面说到两种方案：

- 互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
- 不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；

# 如何保证缓存与数据库双写一致性

**无论是「先更新数据库，再更新缓存」，还是「先更新缓存，再更新数据库」，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象**。

## 旁路缓存策略

**写策略的步骤：**

- 更新数据库中的数据；
- 删除缓存中的数据。

**读策略的步骤：**

- 如果读取的数据命中了缓存，则直接返回数据；
- 如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。

## 最初级的缓存不一致问题及解决方案

问题：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。

解决思路 1：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。

解决思路 2：延时双删。依旧是先更新数据库，再删除缓存，唯一不同的是，我们把这个删除的动作，在不久之后再执行一次，比如 5s 之后。

## 比较复杂的数据不一致问题分析

数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，**查到了修改前的旧数据**，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了...

**解决方案**

1.更新数据的时候

根据数据的唯一标识(key)将操作路由=>发送到一个JVM队列中=>工作线程串行拿到对应的操作=>一条一条执行

2.读取数据的时候

查询不到缓存=>执行更新缓存的操作=>路由到JVM队列(与上面相同)

**需要注意的问题**

- 读请求长时阻塞
- 读请求并发量过高
- 多服务实例部署的请求路由
- 热点商品的路由问题，导致请求的倾斜

# 如何解决Redis的并发竞争问题

- 分布式锁
- 时间戳

# 生产环境中的Redis是怎么部署的

Redis cluster，10 台机器，5 台机器部署了 Redis 主实例，另外 5 台机器部署了 Redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 QPS 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求每秒。

机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10g 内存，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。

5 台机器对外提供读写，一共有 50g 内存。

因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。

你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。