# 高并发架构

## 消息队列

### 为什么使用消息队列

#### 使用场景

##### 解耦

场景：

A系统调用BCD三个系统的接口，如果B系统不需要接收数据了呢？如果又有新系统E需要这份数据呢。并且需要考虑BCDE系统挂了怎么办，是用重发解决还是把消息存起来?

**使用MQ进行解耦**

A系统将消息发送到MQ，BCDE系统谁需要这份消息就去订阅进行消费，这样就进行解耦了。

**总结**

通过一个MQ，PUB/SUB 发布订阅消息这一个模型，A系统就和其它系统进行解耦了。

##### 异步

场景：

A系统接受请求->A系统写库->B系统写库->C系统写库->D系统写库

总共耗时=A系统10ms+B系统200ms+C系统300ms+D系统300ms=810ms

如何优化这个请求耗时降到200ms以内？

**使用MQ进行削峰**

A系统接受请求->向MQ中发送三条消息以供BCD系统进行消费

总共耗时=A系统原本耗时10ms+三条消息入队列耗时10ms=20ms

##### 削峰

场景：

系统在高峰期涌入过量请求，这些请求会涌入MySQL,导致MySQL抗不住然后系统崩溃。

假设每秒钟

5K请求->一秒内支持2K请求的系统->系统崩溃

**使用MQ进行削峰**

5K请求->写入MQ->系统每秒从MQ拉取2K条消息进行消费->MySQL落库

#### 优缺点	

##### 优点

解耦 异步 削峰

##### 缺点

**系统可用性降低**

MQ一挂整套系统崩溃

**系统复杂度提高**

加个MQ进来，会导致可能出现的问题：重复消费，消息丢失，消息传递的顺序性

**一致性问题**

之前异步的处理方案，BC系统消费完写库成功，D系统失败，这就导致了一致性问题。

#### 技术选型

**中小型公司**技术实力较为一般，项目技术挑战不是特别高，用RabbitMQ是不错的选择

**大型公司**基础架构研发实力较强，用RocketMQ是很好的选择。

**大型数据领域**的实时计算,日志采集系统，用Kafka是业内标准的，几乎是全世界这个领域的事实性规范。

### 如何保证消息队列的高可用