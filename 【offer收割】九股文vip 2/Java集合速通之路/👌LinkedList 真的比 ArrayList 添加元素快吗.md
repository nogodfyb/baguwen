性能的比较需要根据具体的操作和数据分布来分析。

1. **尾部插入**：
   - **ArrayList**：在尾部插入元素时，当数据量较小时，由于ArrayList需要频繁扩容，可能会稍显慢一些。但当数据量较大时，ArrayList的扩容策略（通常是当前容量的1.5倍）可以一次提供很多空间，减少了扩容的次数，从而在尾部插入效率上可能超过LinkedList。
   - **LinkedList**：在数据量较小时，尾部插入数据较快，因为每次添加只需要新建一个节点并调整指针。但当数据量大时，每次add()操作都会新建一个节点，这可能会增加时间消耗。
2. **首部插入**：
   - **ArrayList**：在首部插入元素时，由于需要将原数组所有元素向后移动一个位置（通过System.arraycopy方法），效率相对较低。
   - **LinkedList**：在首部插入元素时，只需要调整首尾节点的指针，时间复杂度为O(1)，因此效率较高。
3. **中间插入**：
   - **ArrayList**：在中间插入元素时，同样需要将原数组的元素向后移动以腾出位置，时间复杂度为O(n)，其中n为数组长度。但插入位置越往后，需要复制后移的数据越少，效率相对会高一些。
   - **LinkedList**：在中间插入元素时，需要遍历链表找到插入位置，然后从两端向中间搜索，index越往中间遍历越久，因此效率相对较低。但在数据量较小时，LinkedList的性能可能会超过ArrayList，因为ArrayList在数据量小时需要频繁扩容。
4. **其他注意事项**：
   - **内存消耗**：LinkedList的每个节点都需要额外的空间来存储指针信息，因此在内存消耗上可能会比ArrayList稍大。
   - **线程安全**：ArrayList和LinkedList都不是线程安全的。如果需要在多线程环境下使用，需要考虑额外的同步措施。

综上所述，LinkedList和ArrayList在添加元素时的性能优劣取决于具体的操作和数据分布。在尾部插入大量数据时，ArrayList可能更优；在首部插入数据时，LinkedList更优；而在中间插入数据时，需要根据数据量的大小和插入位置来具体分析。
