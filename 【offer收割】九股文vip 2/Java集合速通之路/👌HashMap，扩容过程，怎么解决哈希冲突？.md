`HashMap` 是 Java 中一个非常常用的数据结构，用于存储键值对映射。了解其扩容过程和哈希冲突解决策略对于理解和高效使用 `HashMap` 非常重要。
### 扩容过程
`HashMap` 的扩容（rehashing）主要发生在以下两种情况下：

1. **当添加元素时，如果当前数组为空，会进行初始化**：默认情况下，会创建一个长度为 16 的数组，并且加载因子（load factor）默认为 0.75。
2. **当数组中的元素数量大于或等于数组长度与加载因子的乘积时**：例如，当数组长度为 16，加载因子为 0.75，并且元素数量达到 12 时（16 * 0.75 = 12），会触发扩容。扩容时，数组长度会翻倍（通常是 2 的幂），并重新哈希所有元素到新的数组中。

在扩容过程中，`HashMap` 会重新计算每个元素的哈希值，并根据新的数组长度重新定位其索引位置。由于数组长度翻倍，哈希值的位运算结果可能会改变，导致元素在新数组中的位置与旧数组不同。
### 哈希冲突解决
哈希冲突（hash collision）是指不同的键计算出相同的哈希值，从而在哈希表中映射到同一个位置。`HashMap` 通过以下策略来解决哈希冲突：

1. **链表法（链表或红黑树）**：在`HashMap`中，每个位置（索引）可以存储一个链表（或红黑树，当链表长度超过一定阈值时）。当发生哈希冲突时，新的元素会被添加到对应的链表中。在 Java 8 及之后的版本中，当链表长度达到 8 且数组长度大于 64 时，链表会转换为红黑树以优化性能。
2. **哈希函数**：为了降低哈希冲突的概率，`HashMap`使用了一个精心设计的哈希函数来计算键的哈希值。这个哈希函数考虑了键对象的哈希码（hashCode）以及键在数组中的索引位置，通过一些位运算得到最终的哈希值。这样可以确保哈希值的分布尽可能均匀，减少冲突的可能性。
3. **初始容量和加载因子**：初始容量和加载因子也会影响哈希冲突的概率。较大的初始容量和较小的加载因子可以降低哈希冲突的概率，但也会增加空间开销。因此，在选择这些参数时需要根据具体需求进行权衡。

总的来说，`HashMap` 通过链表法（或红黑树）和精心设计的哈希函数来解决哈希冲突，并通过扩容和重新哈希来保持哈希表的性能和效率。
