[![11、jvm自适应策略导致的tp99升高.mp4 (25.42MB)](https://gw.alipayobjects.com/mdn/prod_resou/afts/img/A*NNs6TKOR3isAAAAAAAAAAABkARQnAQ)](https://www.yuque.com/docs/176645979?_lake_card=%7B%22status%22%3A%22done%22%2C%22name%22%3A%2211%E3%80%81jvm%E8%87%AA%E9%80%82%E5%BA%94%E7%AD%96%E7%95%A5%E5%AF%BC%E8%87%B4%E7%9A%84tp99%E5%8D%87%E9%AB%98.mp4%22%2C%22size%22%3A26656834%2C%22taskId%22%3A%22u1fa5e10b-4e8a-4d07-ae8f-5bc4e294d34%22%2C%22taskType%22%3A%22upload%22%2C%22url%22%3Anull%2C%22cover%22%3Anull%2C%22videoId%22%3A%22inputs%2Fprod%2Fyuque%2F2024%2F29413969%2Fmp4%2F1719845113760-f32e7b89-3b85-41df-ac03-33ba0da5a2fb.mp4%22%2C%22download%22%3Afalse%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22UpTlH%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22video%22%7D#UpTlH)这道题的初衷和上面那道是一样的，当你简历写了 jvm 调优，ok，好好背这几个案例！阅读完本篇，你会对 jvm 的一些参数有一个比较好的理解，同时将以前的知识可以做了一波融会贯通。<br />本案例为：jvm 配置的参数导致的 fullgc，进而导致了 tp99 进行了升高！<br />本性能优化案例是通用的！大家消化完成，直接套到自己项目即可！<br />本题配备了视频助于理解。
# 背景
我手里当时负责了一个运营系统，这个系统主要是承担营销活动相关配置的一个功能系统。还算是比较重要，毕竟活动配置不了也会影响整体的运营功能。最近发现，每天到晚上 18 点，系统的监控就会出现一些接口缓慢的超时报警，tp99 升高。但是没有影响业务功能。本着好奇宝宝的原则，看了看。（体现你的技术热情给面试官 哈哈）
# 排查步骤
1、 首先我去确认了18 点这个时间点有没有定时任务之类的操作，以及有没有大流量的访问，经过询问小组其他同学，发现在这个时间点，是营销发红包的一个重要节点，业务的峰值会大大的升高。可能产生的问题与此息息相关。<br />2、第二步就是确认是什么原因导致的升高，猜测可能是数据库交互，或者是远程调用其他的微服务 rpc 导致。通过查看接口的调用链，也就是监控系统的提供的 tp99，发现其中产生了 fullgc。而且这个时间段 fullgc 非常的频繁，基本就确定了，fullgc 导致的 tp99 的升高。
> 知识点：
> fullgc 触发的条件有哪些？主要是以下几种。
> 1.Minor GC触发条件：当Eden区满时，触发Minor GC。
> 2.Full GC触发条件：
> 1.（1）调用[System.gc](http://system.gc/)()时，系统建议执行Full GC，但是不必然执行
> 2.（2）老年代空间不足
> 3.（3）方法区空间不足
> 4.（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
> 5.（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代

顺着以上的条件的思路，代码并没有第一种的编写，那基本上确定是老年代空间不足。<br />再顺着这个思路，什么情况下老年代空间会不足？又或者说，什么情况下，对象会进入老年代！
> 1.年龄够了: 躲过15次(默认配置是15次) minorGC 之后从新生代进入老年代；
> 2.大对象: 大对象直接进入老年代。有一个 JVM 参数 '-XX:PretenureSizeThreshold' 设置值为字节数，创建超过该大小的对象直接进入老年代,如果没有配置这个参数,这个值好像默认是1M。
> 3.动态年龄判断：当前放对象的 Survivor 区，相同年龄的一批对象（以及小于该年龄）的总内存大于该区的内存的50%，大于该年龄的其他老对象，就会进入老年代（例如1,2,3岁年龄的对象占了 S 区的50%以上，就会把大于3岁的对象移动到老年代去。所以尽量让 S 区中的对象，占比尽量少于 50%）；
> 4.剩的总量太多: Eden 区存活对象太多，超过了 Survivor 的大小，就直接把这些对象都转移到老年代去。（JDK1.8 空间担保机制）


首先分析第一种情况，如果出现大批量这样的对象，代码中出现了长时间引用(例如:静态Map只加不删）。但是我们可以看到,这些对象在每次FullGC都被释放掉了,说明这批对象存活的时间并不长, 而且代码排查也没发现这种代码,暂时排除这种情况。

第二种情况，大对象。我们到容器下载下来JMap-dump内存快照和JMap-Histo对象统计信息，经过对FullGC钱dump分析，这个基本也排除。

接下来就是第三种和第四种情况，这时候我们需要取查看年轻代三块区域的变化，尤其是Survivor区域，经过分析当时一个情况，S区大小一直在变化，而且基本一致保持在50%以上，这时候想到了一个JVM高版本特性，会自动打开UseAdaptiveSizePolicy(动态调整)，查资料后发现,好多人反应这个参数会导致对象跨过S区，直接跑到老年代的情况，我们看到在调用量持续很高的情况,尽然调整到了17M，这肯定会导致容纳不下当时存活的对象。

> UseAdaptiveSizePolicy开关参数-XX:+UseAdaptiveSizePolicy是一个开关参数，当这个参数打开之后，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。

## 问题解决
关闭AdaptiveSizePolicy的方式<br />开启：-XX:+UseAdaptiveSizePolicy(JDK1.8 Parallel Scavenge收集器默认)<br />关闭：-XX:-UseAdaptiveSizePolicy<br />第二天再次观察问题解决！
