（1）互斥锁<br />一次只能一个线程拥有互斥锁，其他线程只有等待。互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，互斥锁在加锁操作时涉及上下文的切换。<br />（2）自旋锁<br />在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，**不会进入睡眠，而是会在原地自旋**，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，**在加锁时间短暂的环境下会极大的提高效率**。但如果加锁时间过长，则会非常浪费CPU资源<br />（3）读写锁<br />读写锁是特殊的自旋锁。特性是读共享，写互斥，默认是读优先，但是改成了写优先（即上写锁失败时，会拒绝后续所有的读锁）。<br />（4）悲观锁<br />顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。<br />（5）乐观锁<br />顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。<br />（6）信号量<br />是用于线程间同步和互斥的，当一个线程完成操作后就通过信号量通知其它线程，然后别的线程就可以继续进行某些操作了。
