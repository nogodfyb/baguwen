Spring事务失效的场景主要有以下几种。

1. **非public方法使用@Transactional**
   - 场景描述：Spring事务管理是基于AOP实现的，而AOP对于JDK动态代理或CGLib动态代理只会代理public方法。如果事务方法的访问修饰符为非public，SpringAOP无法正确地代理该方法，从而导致事务失效。
   - 示例代码：事务方法的访问修饰符被设置为private、default或protected。
   - 解决方案：将需要事务管理的方法设置为public。
2. **在同类中的非事务方法调用事务方法**
   - 场景描述：Spring的事务管理是通过动态代理实现的，只有通过代理对象调用的方法才能享受到Spring的事务管理。如果在同一个类中，一个没有标记为@Transactional的方法内部调用了一个标记为@Transactional的方法，那么事务是不会起作用的。
   - 解决方案：尽量将事务方法放在不同的类中，或者使用Spring的AopContext.currentProxy()来获取当前类的代理对象，然后通过代理对象调用事务方法。
3. **数据库引擎不支持事务**
   - 场景描述：一些数据库引擎不支持事务，例如MySQL的MyISAM引擎就不支持事务。如果使用的是这类数据库引擎，那么Spring的事务管理就无法起作用。
   - 解决方案：选择支持事务的数据库引擎，如MySQL的InnoDB。
4. **事务属性设置不当**
   - 场景描述：在Spring的事务管理中，如果在一个支持当前事务的方法（比如，已经被标记为@Transactional的方法）中调用了一个需要新事务的方法，如果后者方法抛出了异常，但异常并未被Spring识别为需要回滚事务的异常，那么后者的事务将不会回滚。
   - 解决方案：确保了解和正确使用Spring的事务传播行为，并明确了解何种异常会触发事务回滚。
5. **异常类型不匹配**
   - 场景描述：默认情况下，Spring只有在方法抛出运行时异常或者错误时才会回滚事务。对于检查性异常，即使你在方法中抛出了，Spring也不会回滚事务，除非你在@Transactional注解中显式地指定需要回滚哪些检查性异常。
   - 解决方案：了解Spring事务管理对异常的处理，必要时在@Transactional注解中指定需要回滚的异常类型。
6. **事务嵌套使用不当**
   - 场景描述：在一个已经开启了事务的方法中再次开启事务，如果未正确配置，可能导致预期之外的行为。
   - 解决方案：确保了解Spring的事务传播行为，正确地使用事务嵌套。
7. **数据库表锁定**
   - 场景描述：在事务处理过程中，如果相关的数据表被锁定，那么事务可能无法正常工作。
   - 解决方案：检查并处理数据库表的锁定问题。
8. **数据源配置错误**
   - 场景描述：在配置数据源时，如果没有正确地配置数据源的JDBC驱动类、URL、用户名和密码等信息，就会导致Spring事务失效。
   - 解决方案：确保数据源配置正确。
9. **事务拦截器配置错误**
   - 场景描述：如果没有正确地配置事务拦截器，例如没有指定切入点或指定了错误的切入点，就会导致Spring事务失效。
   - 解决方案：确保事务拦截器配置正确。
10. **事务超时配置错误**
   - 场景描述：如果事务超时时间设置得太短，就有可能在事务执行过程中出现超时，从而导致Spring事务失效。
   - 解决方案：确保事务超时时间设置合理。
