垃圾回收算法的核心在于解决两个问题：一是确定哪些对象能够被回收（引用计数法、可达性分析法），二是如何回收这些对象（标记清除、标记复制、标记整理）。
### 引用计数法
引用计数法（Reference Counting）是一种内存管理技术，用于跟踪对象的引用数量。每个对象都有一个引用计数器，记录着指向该对象的引用数量。<br />当一个对象被引用时，引用计数器加一；当一个引用被释放时，引用计数器减一。当引用计数器为零时，表示没有任何引用指向该对象，该对象可以被释放，回收其占用的内存。
#### 优点：

   - 实时性好：当没有引用指向一个对象时，该对象可以立即被回收，释放内存资源。
   - 简单高效：引用计数法是一种相对简单的内存管理技术，实现起来较为高效。
   - 无需沿指针查找：与GC标记-清除算法不同，引用计数法无需从根节点开始沿指针查找。
#### 缺点

   - 循环引用问题：当存在循环引用的情况下，对象之间的引用计数可能永远不会为零，导致内存泄漏的发生。
   - 额外开销：每个对象都需要维护一个引用计数器，这会带来一定的额外开销。
   - 不支持并发：在多线程环境下，引用计数法需要进行额外的同步操作，以确保引用计数的准确性，可能导致性能损失。
   - 实现复杂：虽然引用计数的算法本身很简单，但实现起来却不容易。
### 可达性分析法
可达性分析算法是JVM垃圾回收中的一种算法，它通过分析对象的引用关系，判断对象是否可达，从而决定对象是否可以被回收。
#### 工作原理

1. GC Roots：在Java中，GC Roots通常包括虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区（静态变量）中引用的对象、本地方法栈中JNI（Native方法）引用的对象等。
2. 搜索过程：可达性分析算法从GC Roots开始，递归地访问所有可达的对象，并给它们打上标记。这个过程可以使用深度优先搜索（DFS）或广度优先搜索（BFS）等图遍历算法来实现。
3. 回收判定：如果一个对象到GC Roots没有任何引用链相连（即该对象从GC Roots不可达），则证明该对象是不可用的，可以判定为可回收对象。
#### 特点

- 准确性：通过从GC Roots开始搜索引用链，可以准确地判断哪些对象是可回收的。
- 效率：结合现代JVM的优化技术，如增量标记、并发标记等，可以提高可达性分析算法的效率。
- 灵活性：可达性分析算法可以与不同的垃圾回收策略（如标记-清除、标记-整理等）结合使用，以适应不同的应用场景和硬件环境。
### 总结来说
引用计数法和可达性分析法是两种不同的内存管理和垃圾回收算法。引用计数法通过维护引用计数器来跟踪对象的引用数量，具有实时性好、简单高效等优点，但存在循环引用等问题；而可达性分析法则通过分析对象的引用关系来判断对象是否可达，从而决定对象是否可以被回收，具有准确性高、效率好等优点，是JVM中常用的垃圾回收算法之一。

### 1. 标记-清除算法

- **原理**：垃圾收集器首先遍历对象图，标记所有可达的对象，然后清除未标记的对象。
- **优点**：简单直接，不需要移动对象。
- **缺点**：会产生内存碎片，可能导致大对象分配失败。
### 2. 标记-压缩算法

- **原理**：在标记阶段标记所有可达的对象后，压缩阶段将存活的对象移动到内存的一端，整理出连续的可用内存空间。
- **优点**：消除了内存碎片问题。
- **缺点**：对象移动需要额外的时间和资源。
### 3. 复制算法

- **原理**：将内存分为两个相等的区域，每次只使用其中一个。当这个区域使用完时，将存活的对象复制到另一个区域，然后清空当前区域。
- **优点**：简单高效，没有内存碎片问题。
- **缺点**：需要双倍的内存空间。
### 4. 分代收集算法

- **原理**：根据对象的生命周期将堆内存划分为几代（通常是新生代和老年代），新生代使用复制算法，老年代使用标记-压缩或标记-清除算法。
- **优点**：优化了垃圾收集性能，因为大部分对象在新生代被收集，减少了老年代的垃圾收集频率。
- **缺点**：需要额外的内存管理和调优。
### 5. 分区算法

- **原理**：将堆内存划分为多个小的独立区域（Region），每个区域可以独立进行垃圾收集。
- **优点**：提高了内存管理的灵活性和效率，适用于大堆内存的应用。
- **缺点**：实现较复杂，需要精细的内存管理。
### 6. 并行和并发收集算法

- **并行收集**：垃圾收集过程由多个线程并行执行，提高了垃圾收集的效率。
- **并发收集**：垃圾收集过程与应用线程并发执行，减少了应用停顿时间。
### 具体垃圾收集器使用的算法

- **Serial GC**：使用标记-压缩算法。
- **Parallel GC**：新生代使用复制算法，老年代使用标记-压缩算法。
- **CMS GC**：新生代使用复制算法，老年代使用标记-清除算法，并发标记和清除。
- **G1 GC**：分区算法，结合标记-压缩和复制算法。
- **ZGC**：分区算法，使用染色指针和读屏障技术，实现并发标记和压缩。
- **Shenandoah GC**：分区算法，使用并发标记和并发压缩技术。
