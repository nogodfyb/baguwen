### 1. 表级锁（Table Locks）
- **表锁（Table Lock）**：表级锁是对整个表进行加锁。它有两种类型：
   - **读锁（Read Lock）**：多个事务可以同时对表加读锁，但不能对表进行写操作。
   - **写锁（Write Lock）**：当一个事务对表加写锁时，其他事务不能对该表进行读或写操作。
- 表锁的优点是实现简单，开销较小，但在高并发情况下可能会导致较多的锁等待和性能瓶颈。
### 2. 行级锁（Row Locks）
行级锁是对单行记录进行加锁，适用于 InnoDB 存储引擎。它的粒度更细，可以提高并发性能。行级锁主要有两种类型：

- **共享锁（Share Lock，S 锁）**：允许事务读取一行数据，但不允许修改。其他事务也可以获得该行的共享锁。
- **排他锁（Exclusive Lock，X 锁）**：允许事务读取和修改一行数据，但不允许其他事务获取该行的任何锁。
### 3. 间隙锁（Gap Locks）
间隙锁是 InnoDB 存储引擎特有的锁，用于防止幻读现象。间隙锁不仅锁定现有的行，还锁定一个范围内的间隙，以防止其他事务在这个间隙内插入新行。

- **间隙锁（Gap Lock）**：锁定一个范围内的间隙，但不锁定间隙中的行。
- **临键锁（Next-Key Lock）**：是行锁和间隙锁的组合，锁定一个行和它前面的间隙。
### 4. 意向锁（Intention Locks）
意向锁是 InnoDB 存储引擎用来支持多粒度锁定的机制，主要用于表级锁和行级锁的协调。意向锁有两种类型：

- **意向共享锁（Intention Share Lock，IS 锁）**：事务打算对某些行加共享锁。
- **意向排他锁（Intention Exclusive Lock，IX 锁）**：事务打算对某些行加排他锁。

意向锁本身不会阻塞其他事务，但会阻止其他事务对表加相冲突的表级锁。
### 5. 自增锁（Auto-Increment Locks）
自增锁用于处理自增列（AUTO_INCREMENT）的并发问题。InnoDB 存储引擎使用一种特殊的表级锁来确保自增列的值在并发插入时的正确性。
### 6. 元数据锁（Metadata Locks）
元数据锁用于保护表结构的变化，确保在表结构变更（如ALTER TABLE）时不会有其他事务对表进行操作。主要用于 DDL（数据定义语言）操作。
### 7. 外键锁（Foreign Key Locks）
外键锁用于保证外键约束的完整性。InnoDB 存储引擎在插入、更新或删除涉及外键的记录时，会自动加锁以确保外键约束不被破坏。
### 8. 临时锁（Temporary Locks）
临时锁是 MySQL 在某些特定操作（如复制、备份等）过程中使用的锁，用于确保操作的原子性和一致性。
