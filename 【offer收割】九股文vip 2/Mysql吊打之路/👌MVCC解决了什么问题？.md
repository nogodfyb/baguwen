### 1.**提高并发性**
MVCC 允许多个事务同时执行读写操作，而无需互相阻塞或等待。这极大地提高了数据库的并发处理能力，特别是在高并发环境中。
### 2.**减少锁争用**
在传统的锁机制中，读写操作需要加锁，容易导致锁争用和死锁问题。MVCC 通过版本控制，使得读取操作不需要加锁，从而减少了锁争用的频率。
### 3.**提供一致性视图**
MVCC 为每个事务提供一个一致性的快照视图，使得事务在执行过程中看到的数据是固定的，不会受到其他并发事务的影响。这简化了应用程序的开发，因为开发者无需担心数据在事务执行过程中发生变化。
### 4.**避免读写冲突**
在 MVCC 中，读操作不会阻塞写操作，写操作也不会阻塞读操作。这避免了读写冲突，提高了系统的整体性能和响应速度。
### 5.**减少死锁**
由于读操作不需要加锁，MVCC 减少了死锁的可能性。死锁通常发生在多个事务互相等待资源释放的情况下，而 MVCC 的无锁读操作减少了这种情况发生的机会。
### 6.**提高读性能**
MVCC 提供了无锁的读操作，读操作直接读取数据的快照版本，不需要等待其他事务完成。这极大地提高了读操作的性能，尤其是在读操作频繁的场景下。
### 7.**实现更高的隔离级别**
MVCC 支持实现更高的隔离级别，如快照隔离（Snapshot Isolation），在这种隔离级别下，事务可以看到一个一致的快照视图，同时避免了脏读和不可重复读等问题。<br />假设有一个银行账户表accounts：
```
+----+--------+
| id | balance|
+----+--------+
| 1  | 1000   |
+----+--------+
```
#### 场景 1：高并发读写

- 事务 A：读取账户余额
- 事务 B：更新账户余额

在传统的锁机制下，事务 A 和事务 B 可能会互相阻塞。然而在 MVCC 中：

1. 事务 A 开始，读取balance = 1000。
2. 事务 B 开始，更新balance为 1200。
3. 事务 A 继续读取，仍然看到balance = 1000。
4. 事务 B 提交后，新的事务可以看到balance = 1200。

这种情况下，事务 A 和事务 B 可以并发执行，互不影响。
#### 场景 2：避免读写冲突

- 事务 C：读取账户余额
- 事务 D：更新账户余额

在 MVCC 中：

1. 事务 C 开始，读取balance = 1000。
2. 事务 D 开始，更新balance为 1500。
3. 事务 D 提交后，新的事务可以看到balance = 1500。
4. 事务 C 继续读取，仍然看到balance = 1000。

通过 MVCC，读取操作和写入操作可以并发执行，避免了读写冲突。
